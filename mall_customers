# TASK 4 - Customer Segmentation using Clustering (Fixed Version)

import pandas as pd
import matplotlib.pyplot as plt
from sklearn.cluster import KMeans, AgglomerativeClustering
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import silhouette_score
import scipy.cluster.hierarchy as sch
import os, warnings

# Suppress MKL warning
os.environ["OMP_NUM_THREADS"] = "1"
warnings.filterwarnings("ignore")

# Load Dataset
df = pd.read_csv("Clustering_Mall_Customers.csv")

# Select relevant features
X = df[['Annual Income (k$)', 'Spending Score (1-100)']]

# Scale Data
scaler = StandardScaler()
X_scaled = scaler.fit_transform(X)

# 1️⃣ Elbow Method for Optimal K
wcss = []
for i in range(1, 11):
    kmeans = KMeans(n_clusters=i, random_state=42, n_init=10)
    kmeans.fit(X_scaled)
    wcss.append(kmeans.inertia_)

plt.plot(range(1, 11), wcss, marker='o')
plt.title('Elbow Method for Optimal k')
plt.xlabel('Number of Clusters (k)')
plt.ylabel('WCSS')
plt.show()

# 2️⃣ Apply K-Means (Optimal K = 5)
kmeans = KMeans(n_clusters=5, random_state=42, n_init=10)
df['Cluster_KMeans'] = kmeans.fit_predict(X_scaled)

# 3️⃣ Apply Hierarchical Clustering (Fixed: metric instead of affinity)
hc = AgglomerativeClustering(n_clusters=5, metric='euclidean', linkage='ward')
df['Cluster_HC'] = hc.fit_predict(X_scaled)

# 4️⃣ Evaluate using Silhouette Score
score_kmeans = silhouette_score(X_scaled, df['Cluster_KMeans'])
score_hc = silhouette_score(X_scaled, df['Cluster_HC'])

print("Silhouette Score (KMeans):", round(score_kmeans, 3))
print("Silhouette Score (Hierarchical):", round(score_hc, 3))

# 5️⃣ Visualize K-Means Clusters
plt.scatter(X_scaled[:,0], X_scaled[:,1], c=df['Cluster_KMeans'], cmap='rainbow')
plt.title('Customer Segments (KMeans)')
plt.xlabel('Annual Income')
plt.ylabel('Spending Score')
plt.show()

# 6️⃣ Dendrogram for Hierarchical Clustering
plt.figure(figsize=(10, 6))
dendrogram = sch.dendrogram(sch.linkage(X_scaled, method='ward'))
plt.title('Dendrogram for Hierarchical Clustering')
plt.xlabel('Customers')
plt.ylabel('Euclidean Distance')
plt.show()
